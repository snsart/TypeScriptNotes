# 高级类型
### 交叉类型
交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。

### 联合类型
联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 number | string | boolean表示一个值可以是 number， string，或 boolean。如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。
```typeScript
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
```

### 类型保护与区分类型
对于联合类型，我们如何确定他们具体是什么类型呢？有三种方法
1.用户自定义类型保护<br>
我们只要简单地定义一个函数，它的返回值是一个 类型谓词：
```typeScript
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```
在这个例子里， pet is Fish就是类型谓词。 谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。<br>
2.typeof类型保护
```typeScript
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```
3.instanceof类型保护<br>
instanceof的右侧要求是一个构造函数

### 类型别名
类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。
```typeScript
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
```
### 数字/字符串字面量类型
可以把字符串字面量和数字字面量当成类型：
```typeScript
type Easing = "ease-in" | "ease-out" | "ease-in-out";


function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {
    // ...
}
```
### 可辨识联合
你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式。
它具有3个要素：
* 具有普通的单例类型属性— 可辨识的特征。
* 一个类型别名包含了那些类型的联合— 联合。
* 此属性上的类型保护。



